# Browser Automation Reliability Plan

## 1. 问题分析
### 1.1 频繁挂起与无响应
- `BrowserControlManager.execute` (`background/managers/control_manager.js:106`) 直接等待各类 action promise，缺少统一的 `Promise.race` 超时及心跳，Chrome DevTools 在导航或输入阻塞时会导致整条链路卡死。
- `WaitForHelper` (`background/control/wait_helper.js`) 只在 DOM 稳定与导航结束后返回，不暴露显式等待/条件等待接口，也未能报告长时间未达成条件的状态。
- `ToolExecutor.executeIfPresent` (`background/handlers/session/prompt/tool_executor.js`) 在执行长耗时工具时无法上报阶段性状态，UI 误以为挂起，遇到异常也没有重试策略。
- 没有集中异常分类或渐进恢复机制，任何 `connection.sendCommand` 抛错都会冒泡到模型层，造成未处理的挂起状态。

### 1.2 用户手动介入后的状态恢复
- `waitForUserIntervention` (`background/managers/control_manager.js:81`) 只是在 overlay 中暂停等待，没有保存当前执行上下文（活跃工具、上一步快照、DOM 版本），恢复后无法校验当前页面是否仍满足下一步条件。
- 控制轮询 `_startControlPolling` 仅侦听按钮点击，不会在继续前触发快照差分或模型状态重建，导致用户手动修改页面后，AI 继续使用过期 selector/状态。
- `PromptHandler` 与 `ToolExecutor` 之间缺少共享状态容器，人工干预后的输出不会同步回提示循环，模型无法重新规划。

### 1.3 复杂任务分步执行的限制
- `PromptHandler` (`background/handlers/session/prompt_handler.js:26`) 将 `MAX_LOOPS` 硬编码为 10，循环超过 10 次直接终止，缺乏任务阶段化或中间总结。
- 没有 checkpoint/阶段性 summary 机制，长任务无法被拆分并持久化进度，浏览器状态与对话历史只能一次性保留在内存。
- 缺少任务切片（segment）策略：工具输出仅以内联文本回传，无法积累结构化上下文，导致复杂流程不可持续执行。

## 2. 解决方案设计
### 2.1 Execution Reliability Layer
1. 引入 `ExecutionWatchdog`（新文件 `background/control/execution_watchdog.js`），统一包装所有工具调用，提供：
   - per-tool timeout（默认 15s，可随动作类型配置），`Promise.race` 超时抛出自定义错误。
   - 心跳/阶段汇报回调，周期性向 UI 更新"等待导航""等待 DOM 稳定"等状态，避免误判为挂起。
   - 指数回退的重试策略，区分可重试错误（Timeout、Element Not Found、Network）与不可重试错误。
2. `WaitForHelper` 扩展条件等待 API：
   - `waitForCondition({expression, timeout, pollInterval})` 支持显式等待。
   - `waitForNetworkIdle({inflightThreshold, timeout})` 监测 `Network.loadingFinished/Failed` 事件，用于复杂导航。
3. `BrowserControlManager.execute` 将所有 action 调用托管给 `ExecutionWatchdog.runWithWatchdog`，并在异常时自动触发 `waitForUserIntervention` 或回退策略，实现"检测-恢复-重试"的闭环。

### 2.2 Intervention-aware State Management
1. 新增 `AutomationStateStore` (`background/managers/automation_state.js`)：
   - 记录当前任务 ID、上一步工具调用、最近快照哈希、DOM 版本、待执行子任务队列。
   - 提供 `saveCheckpoint`, `restoreCheckpoint`, `markUserIntervention`.
2. `waitForUserIntervention`：
   - 调用 `AutomationStateStore.saveCheckpoint('user_pause')` 保存上下文（包括 `SnapshotManager.takeSnapshot`, 当前 request payload）。
   - 在 `_handleContinue` 中先重建上下文：刷新最新快照、对比 DOM hash、识别用户是否改变页面结构；如发生变化则将差异写入"状态同步事件"队列供 Prompt loop 使用。
3. `ToolExecutor` 增加 `postExecutionState` 回调，将 `AutomationStateStore` 中的阶段结果嵌入 tool output，模型可依据结构化信息理解当前状态。
4. `PromptHandler` 重构结束逻辑：若用户介入，自动插入"状态同步系统消息"，提示模型重新规划，而不是继续旧指令。

### 2.3 Task Segmentation & Checkpoints
1. 用 `CheckpointManager` (`background/handlers/session/prompt/checkpoint_manager.js`) 管理论证：
   - 设定 `MAX_LOOPS` 为配置项（例如 `sessionManager.getSetting('maxLoops', 40)`），默认 40。
   - 每 `SEGMENT_SIZE`（默认 5）个循环生成阶段总结（包含工具调用摘要、页面状态、剩余Todo），并持久化到 `AutomationStateStore`.
2. `PromptHandler` 引入阶段循环控制：
   - `while` 循环基于 `currentSegment <= MAX_SEGMENTS`，超过则生成"需要用户确认继续"消息。
   - 在每个阶段结束后，将阶段总结当作新的"system message"加入下一轮 prompt，使模型能够基于 summary 继续执行，支持 10+ 步任务。
3. `ToolExecutor` 将工具输出包装为 `{ type: 'tool_result', checkpointId, files }`，方便 `CheckpointManager` 将输出持久化并在需要时恢复。

## 3. 技术实现方案
### 3.1 新核心模块
- `background/control/execution_watchdog.js`
  - `class ExecutionWatchdog { constructor({defaultTimeout, onProgress}) }`
  - `async runWithWatchdog(actionName, actionFn, {timeout, retries, recoveryPlan})`
  - 捕获错误后调用 `controlManager.updateControlStatus`，必要时触发 `AutomationStateStore.markNeedsRecovery`.
- `background/managers/automation_state.js`
  - `AutomationStateStore` 负责状态读写（可用 `chrome.storage.session`/内存 fallback）。
  - 暴露 `getCurrentContext()`, `saveCheckpoint(label, payload)`, `restoreCheckpoint(label)`, `clear()`.
- `background/handlers/session/prompt/checkpoint_manager.js`
  - `composeSegmentSummary(loopHistory)`，输出结构化 summary。
  - `shouldPauseForSegment(loopCount)` 判断是否需要阶段总结/用户确认。

### 3.2 现有模块改造
1. `BrowserControlManager`
   - 在 `constructor` 中实例化 `ExecutionWatchdog` 与 `AutomationStateStore`，并传入 `BrowserActions`.
   - `execute` 改为 `return await this.watchdog.runWithWatchdog(name, () => this._executeTool(name, args), execOptions);`
   - `_detectBlockingElements` 返回的事件写入 `AutomationStateStore`, 使 Prompt 层可感知。
   - `waitForUserIntervention` 调用 `stateStore.saveCheckpoint('user_pause', context)` 并在 `_handleContinue` 里比较差异。
2. `BrowserActions`
   - 接受 `stateStore` 和 `controlManager`，在每个 action 完成后写入 `stateStore.updateLastAction`.
   - 显式向 `WaitForHelper` 请求 `waitForCondition`/`waitForNetworkIdle`，替换散落在子模块的 `setTimeout`.
3. `WaitForHelper`
   - 新增 `waitForCondition`, `waitForNetworkIdle`, `withTimeout`.
   - 在 `execute` 内部向 `ExecutionWatchdog` 汇报 `onProgress('waiting_for_navigation')`.
4. `ToolExecutor`
   - `executeIfPresent` 在调用 `controlManager.execute` 前后向 `CheckpointManager` 注册输入/输出。
   - 处理 `AutomationStateStore` 返回的 `recoveryPlan`，如果用户介入导致上下文变化，则插入"状态同步"消息。
5. `PromptHandler`
   - 将 `MAX_LOOPS` 改为 `const maxLoops = request.maxLoops || settings.maxLoops || 40;`
   - 集成 `CheckpointManager`：循环开始前检查 `checkpointManager.shouldPauseForSegment(loopCount)`，若 true 则生成 summary 作为下一轮 prompt 输入。
   - 在 `finally` 中根据 `stateStore` 判断是否需要保留未完成段落以供后续继续。

### 3.3 错误恢复&重试策略
- 分类错误：
  - `TimeoutError`: 触发重试（最多 2 次），间隔 `waitHelper` 指数延迟。
  - `StaleContextError`: 自动执行 `SnapshotManager.takeSnapshot` 并重建 selectors。
  - `NavigationInterruption`: 调用 `waitForNetworkIdle` 后重试。
- 每次重试前写入 `AutomationStateStore.appendEvent({type: 'retry', ...})`，供日志与 Prompt 同步。

## 4. 文件修改清单
1. `background/managers/control_manager.js`
   - 集成 `ExecutionWatchdog`、`AutomationStateStore`、超时/重试机制。
   - 在用户干预与继续时保存/恢复上下文，更新状态同步事件。
2. `background/control/execution_watchdog.js` *(新增)*
   - 实现统一超时检测、心跳回调、异常分类与自动恢复。
3. `background/managers/automation_state.js` *(新增)*
   - 管理任务上下文、checkpoint、DOM hash 与 segment 进度。
4. `background/control/wait_helper.js`
   - 扩展条件等待与网络空闲检测 API，增加与 watchdog/状态层的协作 hook。
5. `background/control/actions.js` 及子 action 模块
   - 注入新的 wait/condition API，针对高风险操作（导航、点击、输入）声明执行策略和 timeout。
6. `background/handlers/session/prompt_handler.js`
   - 解耦固定 `MAX_LOOPS`，引入阶段总结、checkpoint 触发点、长任务支持。
7. `background/handlers/session/prompt/tool_executor.js`
   - 向 `CheckpointManager` 报告执行阶段，增强错误与状态同步输出。
8. `background/handlers/session/prompt/checkpoint_manager.js` *(新增)*
   - 负责段落化控制、summary 生成与恢复入口。
9. `background/handlers/session/utils.js`
   - 若需要，扩展 `parseToolCommand` 以识别新的 checkpoint 控制指令（如 `{"tool":"resume_checkpoint"}`）。

## 5. 测试验证方案
1. **单元测试**
   - `ExecutionWatchdog`：模拟 action 超时/成功/重试路径，验证 `onProgress` 与错误分类。
   - `AutomationStateStore`：保存/恢复/清理 checkpoint，确保在 Chrome storage 与内存 fallback 下行为一致。
   - `CheckpointManager`：循环次数达到阈值时正确生成 summary 并要求暂停。
2. **集成测试（可通过 CDP mock 或 Puppeteer harness）**
   - 点击-导航场景：强制 `Page.loadEventFired` 延迟，确认 watchdog 在超时后重试/触发 intervention。
   - 用户手动修改 DOM：在 `waitForUserIntervention` 期间更改页面元素，恢复后验证 stateStore 发现差异并通知 Prompt。
   - 长任务（>15 步）：构造工具序列，确认阶段总结写入 history 且后续步骤使用 summary 继续执行。
3. **回归测试**
   - 常规工具（navigate, click, fill, screenshot）在无干预情况下性能无回退；测量平均执行时间，确保 watchdog 不带来 >5% 额外延迟。
   - 断网/标签页关闭：watchdog 需在 2 次重试后返回明确错误并清理 control overlay。
4. **可观察性**
   - 在 `AutomationStateStore` 增加调试日志（可配置开关），验证 checkpoint/segment 序列。
   - 控制 overlay 显示当前阶段/超时信息，方便人工复核。

---

**会话 ID**: 019bb66d-a1b7-7e22-b6e0-a29f10eba52a
**生成时间**: 2026-01-13
**负责模型**: Codex (后端逻辑优化)
